<!DOCTYPE html><html><head><title>Modal Keys Documentation</title><meta charset="utf-8"><link rel="stylesheet" href="https://haberdashpi.github.io/vscode-modal-keys/stable/README.f14bba23.css"></head><body> <script type="module" src="https://haberdashpi.github.io/vscode-modal-keys/stable/README.ab2e5f5c.js"></script><script src="https://haberdashpi.github.io/vscode-modal-keys/stable/README.16885970.js" nomodule="" defer></script> <div class="content"> <h1 id="heading-#vs-code-commands"><a class="header-anchor" id="vs-code-commands" href="#vs-code-commands"> </a>VS Code Commands</h1> <p>ModalKeys adds several useful commands to VS Code's repertoire. They help you create more Vim-like workflows.</p> <h2 id="heading-#switching-between-modes"><a class="header-anchor" id="switching-between-modes" href="#switching-between-modes"> </a>Switching between Modes</h2> <p>Use the following commands to change the current editor mode. Unless specified below, the command takes no arguments.</p> <table> <thead> <tr><th>Command</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>modalkeys.toggle</code></td><td>Toggles between modes.</td></tr> <tr><td><code>modalkeys.enterNormal</code></td><td>Switches to normal mode.</td></tr> <tr><td><code>modalkeys.enterInsert</code></td><td>Switches to insert mode.</td></tr> <tr><td><code>modalkeys.toggleSelection</code></td><td>Toggles selection mode on or off. Selection mode is implicitly on whenever editor has text selected.</td></tr> <tr><td><code>modalkeys.enableSelection</code></td><td>Turn selection mode on.</td></tr> <tr><td><code>modalkeys.cancelSelection</code></td><td>Cancel selection mode and clear selection.</td></tr> <tr><td><code>modalkeys.cancelMultipleSelections</code></td><td>Cancel selection mode and clear selections, but preserve multiple cursors.</td></tr> <tr><td><code>modalkeys.enterMode</code></td><td>Enter a given mode, specified by the argument <code>mode</code> (a string).</td></tr> </tbody> </table> <h2 id="heading-#incremental-search"><a class="header-anchor" id="incremental-search" href="#incremental-search"> </a>Incremental Search</h2> <p>The standard search functionality in VS Code is quite clunky for some desirable features of a modal editor, as it opens a dialog which takes you out of the editor. To achieve more fluid searching experience ModalKeys provides incremental search commands that mimic Vim's corresponding operations.</p> <h3 id="heading-#modalkeyssearch"><a class="header-anchor" id="modalkeyssearch" href="#modalkeyssearch"> </a><code>modalkeys.search</code></h3> <p>Starts incremental search. The cursor is changed to indicate that editor is in search mode. Normal mode commands are suppressed while incremental search is active. Just type the search string directly without leaving the editor. You can see the searched string in the status bar as well as the search parameters.</p>  <p>The command takes following arguments. All of them are optional.</p> <table> <thead> <tr><th>Argument</th><th>Type</th><th>Default</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>backwards</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Search backwards. Default is forwards</td></tr> <tr><td><code>caseSensitive</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Search is case-sensitive. Default is case-insensitive</td></tr> <tr><td><code>wrapAround</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Search wraps around to top/bottom depending on search direction. Default is off.</td></tr> <tr><td><code>acceptAfter</code></td><td><code>number</code></td><td><code>undefined</code></td><td>Accept search automatically after <em>x</em> characters has been entered. This helps implementing quick one or two character search operations.</td></tr> <tr><td><code>selectTillMatch</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Select the range from current position till the match instead of just the match. Useful with <code>acceptAfter</code> to quickly extend selection till the specified character(s).</td></tr> <tr><td><code>highlightMatches</code></td><td><code>boolean</code></td><td><code>true</code></td><td>If true, use the search highlight colors to highlight all matches</td></tr> <tr><td><code>offset</code></td><td><code>string</code></td><td><code>&quot;inclusive&quot;</code></td><td>Where the cursor should land after searching: &quot;inclusive&quot; of match, &quot;exclusive&quot; of match string, at the &quot;start&quot; or at the &quot;end&quot; of the match.</td></tr> <tr><td><code>executeAfter</code></td><td><code>&lt;command&gt;</code></td><td></td><td>The given commands are run after accepting a search</td></tr> <tr><td><code>text</code></td><td><code>string</code></td><td>&quot;&quot;</td><td>If non-empty, run a non-interactive search using the given text</td></tr> <tr><td><code>regex</code></td><td><code>boolean</code></td><td><code>false</code></td><td>If true, interpret search query as a regular expression</td></tr> <tr><td><code>register</code></td><td><code>string</code></td><td><code>&quot;default&quot;</code></td><td>Register used to store the search text, and current match of that text.</td></tr> </tbody> </table> <p>Changing the register will change what <code>nextMatch</code> and <code>previousMatch</code> consider to be the current search term and location. This allows for multiple channels of searching (e.g. so that emulation of vim's <code>f</code> and <code>/</code> commands can have independent state).</p> <h3 id="heading-#modalkeyscancelsearch"><a class="header-anchor" id="modalkeyscancelsearch" href="#modalkeyscancelsearch"> </a><code>modalkeys.cancelSearch</code></h3> <p>Cancels the incremental search, returns the cursor to the starting position, and switches back to normal mode.</p> <h3 id="heading-#modalkeysdeletecharfromsearch"><a class="header-anchor" id="modalkeysdeletecharfromsearch" href="#modalkeysdeletecharfromsearch"> </a><code>modalkeys.deleteCharFromSearch</code></h3> <p>Deletes the last character of the search string. By default the backspace key is bound to this command when ModalKeys is active and in search mode.</p> <h3 id="heading-#modalkeysnextmatch"><a class="header-anchor" id="modalkeysnextmatch" href="#modalkeysnextmatch"> </a><code>modalkeys.nextMatch</code></h3> <p>Moves to the next match and selectes it. Which way to search depends on the search direction. Takes a single argument (<code>register</code>), which defaults to &quot;default&quot; if unspecified. (See <code>modalkeys.search</code> for details)</p> <h3 id="heading-#modalkeyspreviousmatch"><a class="header-anchor" id="modalkeyspreviousmatch" href="#modalkeyspreviousmatch"> </a><code>modalkeys.previousMatch</code></h3> <p>Moves to the previous match and selectes it. Which way to search depends on the search direction. Takes a single argument (<code>register</code>), which defaults to &quot;default&quot; if unspecified. (See <code>modalkeys.search</code> for details)</p> <h3 id="heading-#modalkeysentermode"><a class="header-anchor" id="modalkeysentermode" href="#modalkeysentermode"> </a><code>modalkeys.enterMode</code></h3> <p>This command takes a single argument <code>mode</code> and allows you to enter any mode you desire.</p> <h2 id="heading-#macros"><a class="header-anchor" id="macros" href="#macros"> </a>Macros</h2> <p>ModalKeys can record events from all modes, other than those from insert mode (support for insert mode is <a href="https://github.com/haberdashPI/vscode-modal-keys/issues/5">planned</a>).</p> <p>There are three commands</p> <h3 id="heading-#modalkeystogglerecordingmacro"><a class="header-anchor" id="modalkeystogglerecordingmacro" href="#modalkeystogglerecordingmacro"> </a><code>modalkeys.toggleRecordingMacro</code></h3> <p>This starts or stops the recording of a macro. When starting a macro, this command accepts a single argument (<code>register</code>). The register determines what name (or number) the macro is stored under. For example, you could pass <code>__count</code> or use <a href="https://haberdashpi.github.io/vscode-modal-keys/stable/doc_index.html#capturing-keys"><code>captureChar</code></a>.</p> <p><strong>LIMITATION</strong>: Macro recording currently ignores all <a href="https://github.com/haberdashPI/vscode-modal-keys/issues/5">insert-mode events</a></p> <h3 id="heading-#modalkeyscancelrecordingmacro"><a class="header-anchor" id="modalkeyscancelrecordingmacro" href="#modalkeyscancelrecordingmacro"> </a><code>modalkeys.cancelRecordingMacro</code></h3> <p>This stops macro recording; unlike <code>toggleRecordingMacro</code>, the new recording is forgotten, and any previous recording stored at the given register is retained.</p> <h3 id="heading-#modalkeysreplaymacro"><a class="header-anchor" id="modalkeysreplaymacro" href="#modalkeysreplaymacro"> </a><code>modalkeys.replayMacro</code></h3> <p>This replays a given macro, indicated by the argument <code>register</code>.</p> <h2 id="heading-#invoking-key-bindings"><a class="header-anchor" id="invoking-key-bindings" href="#invoking-key-bindings"> </a>Invoking Key Bindings</h2> <p>The command <code>modalkeys.typeKeys</code> invokes commands through key bindings. Calling this command with a key sequence has the same effect as pressing the keys in given mode. This allows you to treat key bindings as subroutines that can be called using this command.</p> <p>The command has two arguments.</p> <ol> <li><code>keys</code>: contains the key sequence as string.</li> <li><code>mode</code>: defaults to 'normal', and specifies what mode the keys should be typed in</li> </ol> <p>Assuming that keys <key>k</key> and <key>u</key> are bound to some commands, the following example runs them both one after another.</p> <pre><code class="language-js"><span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;modaledit.typeKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ku&quot;</span> <span class="hljs-punctuation">}</span> <span class="hljs-punctuation">}</span>
</code></pre> <h2 id="heading-#selecting-text-between-delimiters"><a class="header-anchor" id="selecting-text-between-delimiters" href="#selecting-text-between-delimiters"> </a>Selecting Text Between Delimiters</h2> <p>The command <code>modalkeys.selectBetween</code> selects a range of text between two delimiters (<code>from</code> and <code>to</code>), and has several additional arguments.</p> <ul> <li>If the <code>regex</code> flag is on, <code>from</code> and <code>to</code> strings are treated as regular expressions in the search.</li> <li>The <code>inclusive</code> flag tells if the delimiter strings are included in the selection or not. By default the delimiter strings are not part of the selection.</li> <li>The <code>caseSensitive</code> flag makes the search case-sensitive. When this flag is missing or false the search is case-insensitive.</li> </ul> <p>Below is an example that selects all text inside quotation marks. For more advanced examples check the <a href="https://haberdashpi.github.io/vscode-modal-keys/stable/presets/vim.html">vim presets</a>.</p> <pre><code class="language-js"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;modalkeys.selectBetween&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;to&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;)&quot;</span>
    <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre> <blockquote> <p><strong>NOTE</strong>: This command is purely textual in nature. It uses regular expressions to search your document. It cannot understand nested parenthesis and the like. Consider using an extension like <a href="https://marketplace.visualstudio.com/items?itemName=pustelto.bracketeer">bracketeer</a> if you want behavior that handles nested syntactic expressions. VSCode's extension API provides no access to bracket matching, and extensions that want to support this behavior must re-implement bracket matching for all languages they want to support.</p> </blockquote> <h2 id="heading-#repeat-last-change"><a class="header-anchor" id="repeat-last-change" href="#repeat-last-change"> </a>Repeat Last Change</h2> <p><code>modalkeys.repeatLastChange</code> command repeats the last command (sequence) that caused text in the editor to change. It corresponds to the <a href="https://vim.fandom.com/wiki/Repeat_last_change">dot <code>.</code> command</a> in Vim. The command takes no arguments.</p> <h3 id="heading-#touchinguntouching-a-document"><a class="header-anchor" id="touchinguntouching-a-document" href="#touchinguntouching-a-document"> </a>Touching/Untouching a document</h3> <p>To register a change to the document you can call <code>modalkeys.touchDoucment</code>, and to ignore the last change you can call <code>modalkeys.untouchDocument</code>. This can be useful for changing the behavior of <code>repeatLastChange</code>. For example, you might want to treat a command that commits a range of the document to version control, or sends text to a REPL as a change (that can be repeated with <code>repeatLastCahnge</code>).</p> <h2 id="heading-#repeat-last-used-selection"><a class="header-anchor" id="repeat-last-used-selection" href="#repeat-last-used-selection"> </a>Repeat Last Used Selection</h2> <p><code>modalkeys.repeatLastUsedSelection</code> repeats the last command (sequence) that caused the selection to change <em>just before</em> the last change occurred. This is useful for implementing a kakaune-like workflow, where selections are applied and then followed by actions. This is in contrast to the vim-like approach of specifying actions followed by objects (which are kind of like selections, but are not visually displayed). E.g. <key>w</key><key>d</key> in a kakaune-like workflow might select a word (<key>w</key>) and then delete it (<key>d</key>), whereas, in vim, you would type <key>d</key><key>w</key> to delete a word. By repeating the last used selection, you could repeat <key>w</key> and repeating the last change, you could repeat <key>d</key>. Or you could have both repeat commands occur with a single stroke, like below.</p> <pre><code class="language-js">{ <span class="hljs-string">&quot;.&quot;</span>: [ <span class="hljs-string">&quot;modalkeys.repeatLastUsedSelection&quot;</span>, <span class="hljs-string">&quot;modalkeys.repeatLastChange&quot;</span> ] }
</code></pre> <h2 id="heading-#capturing-keys"><a class="header-anchor" id="capturing-keys" href="#capturing-keys"> </a>Capturing keys</h2> <p><code>modalkeys.captureChar</code> is a generic command for capturing a sequence of keys that the user types. It records characters until the user hits return (or until <code>acceptAfter</code> keys are typed). One could implement a poor man's version of the search commands using <code>modalkeys.captureChar</code>. It accepts the following arguments</p> <table> <thead> <tr><th>Argument</th><th>Type</th><th>Default</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>acceptAfter</code></td><td><code>number</code></td><td><code>undefined</code></td><td>Accept search automatically after <em>x</em> characters has been entered.</td></tr> <tr><td><code>execuateAfter</code></td><td>&lt;command&gt;</td><td><code>undefined</code></td><td>The commands to run after capturing keys.</td></tr> </tbody> </table> <p>For example, the following command selects all characters that fall between two instances of a given key; so, in the string &quot;joe |bob| joe&quot;, with the cursor on the first &quot;b&quot;, typing <code>uc|</code> would select &quot;bob&quot;.</p> <pre><code class="language-js">    <span class="hljs-attr">uc:</span> { <span class="hljs-attr">&quot;modalkeys.captureChar&quot;:</span> {
        <span class="hljs-attr">acceptAfter:</span> <span class="hljs-number">1</span>,
        <span class="hljs-attr">executeAfter:</span> { <span class="hljs-attr">&quot;modalkeys.selectBetween&quot;:</span> {
            <span class="hljs-attr">from:</span> <span class="hljs-string">&quot;__captured&quot;</span>,
            <span class="hljs-attr">to:</span> <span class="hljs-string">&quot;__captured&quot;</span>,
            <span class="hljs-attr">inclusive:</span> <span class="hljs-literal">false</span>,
            <span class="hljs-attr">caseSensitive:</span> <span class="hljs-literal">true</span>,
            <span class="hljs-attr">docScope:</span> <span class="hljs-literal">true</span>
        }},
    }}<span class="hljs-string">,</span>
</code></pre> <a href="https://github.com/haberdashPI/vscode-modal-keys">View on GitHub</a> </div> </body></html>